use std::{any::TypeId, cmp::Ordering, mem::ManuallyDrop, sync::OnceLock};

use crate::{entry::GroupEntry, Bencher};

/// Compile-time entry for a generic benchmark function, generated by
/// `#[divan::bench]`.
///
/// Unlike `BenchEntry`, this is for a specific generic type or `const`.
///
/// Although this type contains trivially-`Copy` data, it *should not* implement
/// `Clone` because the memory address of each instance is used to determine the
/// relative order in `GroupEntry.generic_benches` when sorting benchmarks by
/// location.
pub enum GenericBenchEntry {
    /// Generic type.
    Type {
        /// The associated group, for entry metadata.
        group: &'static GroupEntry,

        /// The benchmarking function.
        bench: fn(Bencher),

        /// [`std::any::type_name`].
        get_type_name: fn() -> &'static str,

        /// [`std::any::TypeId::of`].
        get_type_id: fn() -> TypeId,
    },

    /// `const` generic.
    Const {
        /// The associated group, for entry metadata.
        group: &'static GroupEntry,

        /// The benchmarking function.
        bench: fn(Bencher),

        /// The `const` value and associated data.
        value: EntryConst,
    },
}

impl GenericBenchEntry {
    pub(crate) fn raw_name(&self) -> &str {
        match self {
            Self::Type { get_type_name, .. } => get_type_name(),
            Self::Const { value, .. } => value.name(),
        }
    }

    pub(crate) fn display_name(&self) -> &str {
        match self {
            Self::Type { get_type_name, .. } => {
                let mut type_name = get_type_name();

                // Remove module components in type name.
                while let Some((prev, next)) = type_name.split_once("::") {
                    // Do not go past generic type boundary.
                    if prev.contains('<') {
                        break;
                    }
                    type_name = next;
                }

                type_name
            }
            Self::Const { value, .. } => value.name(),
        }
    }

    #[inline]
    pub(crate) fn group(&self) -> &'static GroupEntry {
        match self {
            Self::Type { group, .. } | Self::Const { group, .. } => group,
        }
    }
}

/// A reference to a `const` as a `&'static T`.
pub struct EntryConst {
    /// `&'static T`.
    value: *const (),

    /// [`PartialOrd::partial_cmp`].
    partial_cmp: unsafe fn(*const (), *const ()) -> Option<Ordering>,

    /// [`ToString::to_string`].
    to_string: unsafe fn(*const ()) -> String,

    /// Cached `to_string` result.
    cached_string: ManuallyDrop<OnceLock<&'static str>>,
}

// SAFETY: `T: Send + Sync`.
unsafe impl Send for EntryConst {}
unsafe impl Sync for EntryConst {}

impl EntryConst {
    /// Creates entry data for a `const` values.
    pub const fn new<T>(value: &'static T) -> Self
    where
        T: PartialOrd + ToString + Send + Sync,
    {
        unsafe fn partial_cmp<T: PartialOrd>(a: *const (), b: *const ()) -> Option<Ordering> {
            T::partial_cmp(&*a.cast(), &*b.cast())
        }

        unsafe fn to_string<T: ToString>(value: *const ()) -> String {
            T::to_string(&*value.cast())
        }

        Self {
            value: value as *const T as *const (),
            partial_cmp: partial_cmp::<T>,
            to_string: to_string::<T>,
            cached_string: ManuallyDrop::new(OnceLock::new()),
        }
    }

    /// Returns [`PartialOrd::partial_cmp`] ordering if `<` or `>, falling back
    /// to comparing [`ToString::to_string`] otherwise.
    pub(crate) fn cmp_name(&self, other: &Self) -> Ordering {
        if self.partial_cmp == other.partial_cmp {
            // SAFETY: Both constants have the same comparison function, so they
            // must be the same type.
            if let Some(ordering) = unsafe { (self.partial_cmp)(self.value, other.value) } {
                if !ordering.is_eq() {
                    return ordering;
                }
            }
        }

        // Fallback to name comparison.
        self.name().cmp(other.name())
    }

    /// [`ToString::to_string`].
    #[inline]
    pub(crate) fn name(&self) -> &str {
        self.cached_string.get_or_init(|| {
            // SAFETY: The function is guaranteed to call `T::to_string`.
            let string = unsafe { (self.to_string)(self.value) };

            Box::leak(string.into_boxed_str())
        })
    }
}
